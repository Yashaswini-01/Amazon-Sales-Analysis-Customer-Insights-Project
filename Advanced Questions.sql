-- Business Probelms
-- Advanced Analysis
/*
1. Top Selling Products
Query the top 10 products by total sales value.
Challenge: Include product name, total quantity sold, and total sales value.
*/

SELECT * FROM order_items
ORDER BY quantity DESC;

ALTER TABLE order_items
ADD COLUMN total_sales FLOAT;

UPDATE order_items
SET total_sales = quantity * price_per_unit;

-- Top 10 Selling Products by Total Sales Value (Rounded to 2 Decimal Places)
SELECT 
    p.product_name AS product_name,
    SUM(oi.quantity) AS total_quantity_sold,              
    ROUND(SUM(oi.quantity * oi.price_per_unit)::numeric, 2) AS total_sales  
JOIN order_items oi
    ON p.product_id = oi.product_id
GROUP BY p.product_name                                  
ORDER BY total_sales DESC                                
LIMIT 10;                                                 


/*
2. Revenue by Category
Calculate total revenue generated by each product category.
Challenge: Include the percentage contribution of each category to total revenue.
*/

SELECT SUM(total_sales) FROM order_items;

SELECT * FROM order_items;
SELECT 
	c.category_id AS category_id,
	c.category_name AS category_name,
	ROUND(SUM(oi.quantity * oi.price_per_unit)::numeric, 2) AS total_revenue,
	SUM(oi.total_sales)/(SELECT SUM(total_sales) FROM order_items) *100 AS Contribution
FROM order_items oi
JOIN products p
ON oi.product_id=p.product_id
LEFT JOIN category c
ON p.category_id=c.category_id
GROUP BY 1,2
ORDER BY 3 DESC;

/*
3. Average Order Value (AOV)
Compute the average order value for each customer.
Challenge: Include only customers with more than 5 orders.
*/

-- ORDER,ORDER ITEM,CUSTOMER

SELECT c.customer_id,
CONCAT(f_name,' ',l_name) AS customer_name,
COUNT(o.order_id) AS total_orders,
ROUND((SUM(oi.total_sales)/COUNT(o.order_id))::numeric,2) AS avg_order_value
FROM customers c
JOIN orders o
ON c.customer_id=o.customer_id
LEFT JOIN order_items oi
ON oi.order_id=o.order_id
GROUP BY c.customer_id,customer_name
HAVING COUNT(o.order_id)>5
ORDER BY avg_order_value DESC;
WHERE COUNT(oi.order_item_id) > 5;


/*
4. Monthly Sales Trend
Query monthly total sales over the past year.
Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!
*/

SELECT 
	year,
	month,
	total_sales as current_month_sale,
	LAG(total_sales,1) OVER (ORDER BY year,month) as last_month_sale
FROM
(
SELECT 
	EXTRACT(MONTH FROM o.order_date) as month,
	EXTRACT(YEAR FROM o.order_date) as year,
	ROUND(SUM(oi.total_sales)::numeric,2) as total_sales
FROM orders o
JOIN order_items oi
ON o.order_id=oi.order_id
WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 YEAR'
GROUP BY 1,2
ORDER BY year,month
) AS last_month_sale

/*
5. Customers with No Purchases
Find customers who have registered but never placed an order.
Challenge: List customer details and the time since their registration.
*/

SELECT c.customer_id,
		CONCAT(c.f_name,' ',c.l_name) AS full_name
FROM customers c
LEFT JOIN orders o
	ON c.customer_id=o.customer_id
WHERE o.order_id IS NULL;


SELECT *
FROM customers
WHERE customer_id NOT IN (SELECT 
					DISTINCT customer_id
				FROM orders
				);
				
/*
6. Least-Selling Categories by State
Identify the least-selling product category for each state.
Challenge: Include the total sales for that category within each state.
*/

WITH least_rank AS(
SELECT 
	c.state,
	cate.category_name,
	ROUND(SUM(oi.total_sales)::numeric,2) AS total_sales,
	RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.total_sales) ASC) as rank
FROM orders o
JOIN customers c
ON o.customer_id=c.customer_id
JOIN order_items as oi
ON o.order_id=oi.order_id
JOIN products p
ON oi.product_id=p.product_id
JOIN category cate
ON p.category_id=cate.category_id
GROUP BY 1,2
)
SELECT * FROM least_rank WHERE rank=1;

/*
7. Best-Selling Categories by State
Identify the best-selling product category for each state.
Challenge: Include the total sales for that category within each state.
*/

WITH best_rank AS(
SELECT 
	c.state,
	cate.category_name,
	ROUND(SUM(oi.total_sales)::numeric,2) AS total_sales,
	RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.total_sales) DESC) as rank
FROM orders o
JOIN customers c
ON o.customer_id=c.customer_id
JOIN order_items as oi
ON o.order_id=oi.order_id
JOIN products p
ON oi.product_id=p.product_id
JOIN category cate
ON p.category_id=cate.category_id
GROUP BY 1,2
)
SELECT * FROM best_rank;


/*
7. Customer Lifetime Value (CLTV)
Calculate the total value of orders placed by each customer over their lifetime.
Challenge: Rank customers based on their CLTV.
*/

SELECT 
	c.customer_id,
	CONCAT(c.f_name, ' ',  c.l_name) as full_name,
	ROUND(SUM(oi.total_sales)::numeric,2) as total_value_of_orders,
	DENSE_RANK() OVER(ORDER BY SUM(oi.total_sales) DESC) AS customer_rank
FROM customers c
JOIN orders o
ON c.customer_id=o.customer_id
JOIN order_items oi
ON o.order_id=oi.order_id
GROUP BY 1,2;


/*
8. Inventory Stock Alerts
Query products with stock levels below a certain threshold (e.g., less than 10 units).
Challenge: Include last restock date and warehouse information.
*/

SELECT p.product_id,
		p.product_name,
		i.stock,
		i.warehouse_id,
		i.last_stock_date
FROM inventory i
JOIN products p
ON i.product_id=p.product_id
WHERE i.stock < 10
ORDER BY i.stock ASC;


/*
9. Shipping Delays
Identify orders where the shipping date is later than 3 days after the order date.
Challenge: Include customer, order details, and delivery provider.
*/

SELECT 
	c.customer_id,
	CONCAT(c.f_name, ' ',  c.l_name) as full_name,
	o.order_id,
	s.shipping_providers,
	o.order_date,
	s.shipping_date
FROM customers c
JOIN orders o
ON c.customer_id=o.customer_id
JOIN shipping s
ON o.order_id=s.order_id
WHERE s.shipping_date > o.order_date + INTERVAL '3 days';

/*
10. Payment Success Rate 
Calculate the percentage of successful payments across all orders.
Challenge: Include breakdowns by payment status (e.g., failed, pending).
*/

SELECT 
    p.payment_status,                                
    COUNT(p.payment_id) AS total_payments,          
    ROUND(COUNT(p.payment_id) * 100.0 / SUM(COUNT(p.payment_id)) OVER (), 2) AS percentage 
FROM payments p
GROUP BY p.payment_status                           
ORDER BY percentage DESC;                          

/*
11. Top Performing Sellers
Find the top 5 sellers based on total sales value.
Challenge: Include both successful and Cancelled orders, and display their percentage of successful orders.
*/

SELECT 
	order_status,
	COUNT(*)
	FROM orders
	GROUP BY 1;

WITH top_sellers AS (
 SELECT 
		s.seller_id,
        s.seller_name,
        ROUND(SUM(oi.total_sales)::numeric,2) AS total_sales
    FROM sellers s
    JOIN orders o
        ON s.seller_id = o.seller_id
    JOIN order_items oi
        ON o.order_id = oi.order_id
    GROUP BY s.seller_id,s.seller_name
	ORDER BY 3 DESC
	LIMIT 5
),

seller_reports
AS
(
SELECT 
	o.seller_id,
	ts.seller_name,
	o.order_status,
	COUNT(o.order_id) as total_orders
	FROM orders o
	JOIN top_sellers ts
	ON o.seller_id=ts.seller_id
	WHERE o.order_status NOT IN('Returned','Inprogress')
	GROUP BY 1,2,3
)
-- SELECT *
-- FROM seller_reports
-- ORDER BY 1;

SELECT 
	seller_id,
	seller_name,
	SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END) as Completed_orders,
	SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END) as Cancelled_orders,
	SUM(total_orders) as total_orders,
	ROUND((SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END)::numeric/
	SUM(total_orders)::numeric * 100)::numeric,2) as successful_orders_percentage
	
FROM seller_reports
GROUP BY 1, 2
ORDER BY 6 DESC;

-- Finding all the order_status percentages
SELECT 
	order_status,
	COUNT(*)
	FROM orders
	GROUP BY 1;

WITH top_sellers AS (
 SELECT 
		s.seller_id,
        s.seller_name,
        ROUND(SUM(oi.total_sales)::numeric,2) AS total_sales
    FROM sellers s
    JOIN orders o
        ON s.seller_id = o.seller_id
    JOIN order_items oi
        ON o.order_id = oi.order_id
    GROUP BY s.seller_id,s.seller_name
	ORDER BY 3 DESC
	LIMIT 5
),

seller_reports
AS
(
SELECT 
	o.seller_id,
	ts.seller_name,
	o.order_status,
	COUNT(o.order_id) as total_orders
	FROM orders o
	JOIN top_sellers ts
	ON o.seller_id=ts.seller_id
	GROUP BY 1,2,3
)
SELECT 
	seller_id,
	seller_name,
	SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END) as Completed_orders,
	SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END) as Cancelled_orders,
	SUM(CASE WHEN order_status='Returned' THEN total_orders ELSE 0 END ) as Returned_orders,
	SUM(CASE WHEN order_status='Inprogress' THEN total_orders ELSE 0 END) as InProgress_orders,
	SUM(total_orders) as total_orders,
	ROUND((SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END)::numeric/
	SUM(total_orders)::numeric * 100)::numeric,2) as successful_orders_percentage,
	ROUND((SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END)::numeric/
	SUM(total_orders)::numeric * 100)::numeric,2) as Cancelled_orders_percentage,
	ROUND((SUM(CASE WHEN order_status = 'Returned' THEN total_orders ELSE 0 END)::numeric/
	SUM(total_orders)::numeric * 100)::numeric,2) as Returned_orders_percentage,
	ROUND((SUM(CASE WHEN order_status = 'Inprogress' THEN total_orders ELSE 0 END)::numeric/
	SUM(total_orders)::numeric * 100)::numeric,2) as InProgress_orders_percentage
	
FROM seller_reports
GROUP BY 1, 2
ORDER BY 6 DESC;



/*
12. Product Profit Margin
Calculate the profit margin for each product (difference between price and cost of goods sold).
Challenge: Rank products by their profit margin, showing highest to lowest.
*/

-- cogs means cost of goods
--profit would be SUM(total_sales - cogs*quantity)

SELECT 
    p.product_id,
    p.product_name,
    ROUND((SUM(oi.total_sales - p.cogs * oi.quantity) / 100)::numeric, 2) AS profit,  
    ROUND(((SUM(oi.total_sales - p.cogs * oi.quantity) * 100.0) / SUM(oi.total_sales))::numeric, 2) AS profit_margin,  -- Profit margin as percentage
    DENSE_RANK() OVER (ORDER BY 
        (SUM(oi.total_sales - p.cogs * oi.quantity) * 100.0) / SUM(oi.total_sales) DESC
    ) AS profit_ranking  -- Rank products by profit margin, highest to lowest
FROM products p
JOIN order_items oi
    ON p.product_id = oi.product_id
GROUP BY p.product_id, p.product_name
ORDER BY profit_ranking;


/*
13. Most Returned Products
Query the top 10 products by the number of returns.
Challenge: Display the return rate as a percentage of total units sold for each product.
*/

SELECT 
    p.product_id,
    p.product_name,
    COUNT(*) AS total_units_sold, --count all rows in the order_items table
    SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returns,
    ROUND(
        SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END)::numeric / COUNT(*)::numeric * 100,
        2
    ) AS return_percentage,
    DENSE_RANK() OVER (ORDER BY 
        ROUND(SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END)::numeric / COUNT(*)::numeric * 100, 2) DESC
    ) AS return_rank
FROM order_items AS oi
JOIN products AS p
    ON oi.product_id = p.product_id
JOIN orders AS o
    ON o.order_id = oi.order_id
GROUP BY p.product_id, p.product_name
ORDER BY return_percentage DESC
LIMIT 10;


/*
14. Orders Pending Shipment
Find orders that have been paid but are still pending shipment.
Challenge: Include order details, payment date, and customer information.
*/

SELECT 
o.order_id,
o.order_status,
c.customer_id,
p.payment_date,
p.payment_status,
s.delivery_status
FROM customers c
JOIN orders o
ON c.customer_id=o.customer_id
JOIN payments p
ON o.order_id=p.order_id
JOIN shipping s
ON p.order_id=s.order_id
WHERE p.payment_status='Payment Successed' AND s.delivery_status='Inprogress'
ORDER BY p.payment_date DESC;


/*
15. Inactive Sellers
Identify sellers who havenâ€™t made any sales in the last 6 months.
Challenge: Show the last sale date and total sales from those sellers.
*/

WITH inactive_sellers AS(
SELECT * FROM
sellers
WHERE seller_id NOT IN
(
SELECT seller_id FROM
orders
WHERE order_date >= CURRENT_DATE - INTERVAL '6 months')
)
SELECT 
o.seller_id,
i.seller_name,
MAX(o.order_date) AS last_order_date,
ROUND(SUM(oi.total_sales)::numeric,2) AS total_sales
FROM orders o
JOIN inactive_sellers i
ON o.seller_id = i.seller_id
JOIN order_items oi
ON o.order_id=oi.order_id
GROUP BY 1,2
ORDER BY 3 DESC


/*
16. IDENTITY customers into returning or new
if the customer has done more than 5 return categorize them as returning otherwise new
Challenge: List customers id, name, total orders, total returns
*/

SELECT
  c.customer_id,
  CONCAT(c.f_name, ' ', c.l_name) AS customer_name,
  COUNT(o.order_id) AS total_orders,
  SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returns,
  CASE 
    WHEN SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) > 5 THEN 'Returning'
    ELSE 'New'
  END AS customer_category
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.f_name, c.l_name
ORDER BY total_returns DESC;



/*
17. Cross-Sell Opportunities
Find customers who purchased product A but not product B (e.g., customers who bought AirPods but not AirPods Max).
Challenge: Suggest cross-sell opportunities by displaying matching product categories.
*/

WITH customer_purchases AS (
    SELECT 
        c.customer_id,
        CONCAT(c.f_name, ' ', c.l_name) as customer_name,
        cat.category_id,
        cat.category_name,
        array_agg(DISTINCT p.product_name) as bought_products
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    JOIN category cat ON p.category_id = cat.category_id
    GROUP BY c.customer_id, c.f_name, c.l_name, cat.category_id, cat.category_name
),
top_recommendation AS (
    SELECT 
        cp.customer_id,
        cp.customer_name,
        cp.category_name,
        p2.product_name as recommended_product,
        p2.price as price,
        ROW_NUMBER() OVER (PARTITION BY cp.customer_id, cp.category_name ORDER BY p2.price DESC) as rn
    FROM customer_purchases cp
    JOIN products p2 ON cp.category_id = p2.category_id
    WHERE NOT p2.product_name = ANY(cp.bought_products)
)
SELECT 
    customer_id,
    customer_name,
    category_name,
    recommended_product,
    price
FROM top_recommendation
WHERE rn = 1
ORDER BY customer_id, price DESC;


/*
18. Top 5 Customers by Orders in Each State
Identify the top 5 customers with the highest number of orders for each state.
Challenge: Include the number of orders and total sales for each customer.
*/

WITH customer_rankings AS (
    SELECT 
        c.customer_id,
        CONCAT(c.f_name, ' ', c.l_name) AS customer_name,
        c.state,
        COUNT(DISTINCT o.order_id) as total_orders,
        ROUND(SUM(oi.quantity * oi.price_per_unit)::numeric, 2) as total_sales,
        DENSE_RANK() OVER(PARTITION BY c.state ORDER BY COUNT(DISTINCT o.order_id) DESC) as rank_by_orders
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_id, c.f_name, c.l_name, c.state
)
SELECT 
    customer_id,
    customer_name,
    state,
    total_orders,
    total_sales,
	rank_by_orders
FROM customer_rankings
WHERE rank_by_orders <= 5
ORDER BY state,rank_by_orders;


/*
19. Revenue by Shipping Provider
Calculate the total revenue handled by each shipping provider.
Challenge: Include the total number of orders handled and the average delivery time for each provider.
*/

SELECT 
    s.shipping_providers,
    COUNT(o.order_id) AS total_orders,
    ROUND(SUM(oi.total_sales)::numeric, 2) AS total_sales,
    ROUND(COALESCE(AVG(s.shipping_date - o.order_date),0), 2) AS avg_delivery_time_days,
    ROUND(COALESCE(AVG(s.return_date - s.shipping_date), 2)) AS avg_return_time_days
FROM shipping s
JOIN orders o
    ON s.order_id = o.order_id
JOIN order_items oi
    ON o.order_id = oi.order_id
GROUP BY s.shipping_providers
ORDER BY total_sales DESC;



/*
20. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)
Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio at end Round the result

Note: Decrease ratio = cr-ls/ls* 100 (cs = current_year ls=last_year)
*/


WITH RevenueByYear AS (
    SELECT 
        p.product_id,
        p.product_name,
        c.category_name,
        EXTRACT(YEAR FROM o.order_date) AS year,
        SUM(oi.total_sales) AS revenue
    FROM products p
    JOIN order_items oi ON p.product_id = oi.product_id
    JOIN orders o ON oi.order_id = o.order_id
    JOIN category c ON p.category_id = c.category_id
    WHERE EXTRACT(YEAR FROM o.order_date) IN (2022, 2023)
    GROUP BY p.product_id, p.product_name, c.category_name, year
),
RevenueComparison AS (
    SELECT 
        r1.product_id,
        r1.product_name,
        r1.category_name,
        r1.revenue AS revenue_2022,
        r2.revenue AS revenue_2023,
        ROUND(((r2.revenue - r1.revenue) / r1.revenue)::numeric * 100, 2) AS decrease_ratio
    FROM RevenueByYear r1
    LEFT JOIN RevenueByYear r2 ON r1.product_id = r2.product_id 
    WHERE r1.year = 2022 AND r2.year = 2023 AND r1.revenue > 0
)
SELECT 
    product_id,
    product_name,
    category_name,
    ROUND(revenue_2022::numeric, 2) AS revenue_2022,
    ROUND(revenue_2023::numeric, 2) AS revenue_2023,
    decrease_ratio
FROM RevenueComparison
ORDER BY decrease_ratio ASC 
LIMIT 10;



